// 1先转成二进制  在左移n位  然后补0
// 比如 1<<2     1的二进制为 0000 0001   左移2位  0000 0100.
// n=1 即 1*2  ， n=2 既1*2*2 ，n=3 既1*2*2*2
// 就是进行二进制的翻倍。
// 二进制每左移一位就是*2，两位就是*2*2,三位就是*2*2*2.
// 1>>n就是1右移n位
// n>>1就是n右移1位
// 1<<n就是1左移n位
// n<<1就是n左移1位
// int m=1<<n
// 就是m的值为把1左移n个二进制位的值
// 注意是在二进制下

// 假设有四根木棍（1111），则这四根木棍的组合是16种：0000、0001、0010…1111 即2^n种。
// 那么通过木棍的长度，我们就能得出每一种组合的总长度是多少。
// 将这个组合 和 其它组合进行比较，如果其它组合和这个组合中有相同的木棍，就舍弃，如果没有，则判断这两个组合长度是否相等，如果相等则与最大长度比较和替换。

// 将左移j位的1与i进行按位与，就是保留i转换为二进制数后的第j位数，其他的都改为零，如果第j位数为0，则i&(1<<j)的值为0，否则不为0

// 1<< i 就是左移 i 位，得到的是2的 i 次方

// 例如 1<<2

// 00000001   ------>    00000100    ------>2的2次方 = 4

// i &(1<< j )就是将左移 j 位的1与 i 进行按位与

// 例如  5 & (1<<2)

// 5 转换为二进制数是 0101

// 1<<2  得到的是 0100

// 将 0101 与 0100 进行按位与

// 0    1    0    1

// |      |     |     |       -->     0&0=0 , 1&1=1 , 0&0=0 , 1&0 = 0

// 0    1    0    0      得到的数就是0100  =  4 ≠ 0
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    int n;
    cin >> n;
    vector<int> v;
    for (int i = 0; i < n; i++)
    {
        int num;
        cin >> num;
        v.push_back(num);
    }
    vector<int> v2((1 << n));
    //(1<<n)即2^n
    for (int i = 0; i < (1 << n); i++)
    {
        //有n根木棒
        for (int j = 0; j < n; j++)
        {
            //说明这个状态有这根木棒
            if (i & (1 << j))
            {
                v2[i] += v[j];
            }
        }
    }
    int result = 0;
    //组合之间进行比较
    for (int i = 0; i < (1 << n); i++)
    {
        for (int j = 0; j < (1 << n); j++)
        {
            //状态不同但是值相同 !(i&j)是为了判断两个组合中是否包含相同的木棒，如果包含相同的木棒，那么值不会是0
            if (!(i & j) && v2[i] == v2[j])
            {
                result = max(result, v2[i]);
            }
        }
    }
    cout << result;
    return 0;
}